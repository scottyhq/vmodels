'''
%OKADA85 Surface deformation due to a finite rectangular source.
%	[uE,uN,uZ,uZE,uZN,uNN,uNE,uEN,uEE] = OKADA85(...
%	   E,N,DEPTH,STRIKE,DIP,LENGTH,WIDTH,RAKE,SLIP,OPEN)
%	computes displacements, tilts and strains at the surface of an elastic
%	half-space, due to a dislocation defined by RAKE, SLIP, and OPEN on a
%	rectangular fault defined by orientation STRIKE and DIP, and size LENGTH and
%	WIDTH. The fault centroid is located (0,0,-DEPTH).
%
%	   E,N    : coordinates of observation points in a geographic referential
%	            (East,North,Up) relative to fault centroid (units are described below)
%	   DEPTH  : depth of the fault centroid (DEPTH > 0)
%	   STRIKE : fault trace direction (0 to 360 relative to North), defined so
%	            that the fault dips to the right side of the trace
%	   DIP    : angle between the fault and a horizontal plane (0 to 90)
%	   LENGTH : fault length in the STRIKE direction (LENGTH > 0)
%	   WIDTH  : fault width in the DIP direction (WIDTH > 0)
%	   RAKE   : direction the hanging wall moves during rupture, measured relative
%	            to the fault STRIKE (-180 to 180).
%	   SLIP   : dislocation in RAKE direction (length unit)
%	   OPEN   : dislocation in tensile component (same unit as SLIP)
%
%	returns the following variables (same matrix size as E and N):
%	   uN,uE,uZ        : displacements (unit of SLIP and OPEN)
Orginal matlab function from:
http://www.mathworks.com/matlabcentral/fileexchange/25982-okada--surface-deformation-due-to-a-finite-rectangular-source/content/okada85.m
'''
# Autogenerated with SMOP version
# envs/py27/bin/smop -v okada85.m -o okada85.py
# Autoformatted with autopep8
# autopep8 -i okada85.py
# Manually cleaned up by Scott Henderson
# 05/24/2016

from __future__ import division
import numpy as np
import matplotlib.pyplot as plt


eps = 1e-14 #

# Match input variable order as closely as possible
#def calc_mogi(x,y,xoff=0,yoff=0,d=3e3,dV=1e6,nu=0.25,output='cyl'):
#def forward(E,N,DEPTH,STRIKE,DIP,LENGTH,WIDTH,RAKE,SLIP,OPEN):
def forward(x, y, xoff=0, yoff=0,
            depth=5e3, length=1e3, width=1e3, 
            slip=0.0, opening=10.0, 
            strike=0.0, dip=0.0, rake=0.0,
            nu=0.25):
    '''
    Calculate surface displacements for Okada85 dislocation model
    '''
    e = x
    n = y
    x = x - xoff
    y = y - yoff    

    strike = np.deg2rad(strike)
    dip = np.deg2rad(dip)
    rake = np.deg2rad(rake)
    
    L = length
    W = width

    U1 = np.cos(rake) * slip
    U2 = np.sin(rake) * slip
    U3 = opening
    
    d = depth + np.sin(dip) * W / 2
    ec = e + np.cos(strike) * np.cos(dip) * W / 2
    nc = n - np.sin(strike) * np.cos(dip) * W / 2
    x = np.cos(strike) * nc + np.sin(strike) * ec + L / 2
    y = np.sin(strike) * nc - np.cos(strike) * ec + np.cos(dip) * W
    p = y * np.cos(dip) + d * np.sin(dip)
    q = y * np.sin(dip) - d * np.cos(dip)

    ux = - U1 / (2 * np.pi) * chinnery(ux_ss, x, p, L, W, q, dip, nu) - \
           U2 / (2 * np.pi) * chinnery(ux_ds, x, p, L, W, q, dip, nu) + \
           U3 / (2 * np.pi) * chinnery(ux_tf, x, p, L, W, q, dip, nu)
    uy = - U1 / (2 * np.pi) * chinnery(uy_ss, x, p, L, W, q, dip, nu) - \
           U2 / (2 * np.pi) * chinnery(uy_ds, x, p, L, W, q, dip, nu) + \
           U3 / (2 * np.pi) * chinnery(uy_tf, x, p, L, W, q, dip, nu)
    uz = - U1 / (2 * np.pi) * chinnery(uz_ss, x, p, L, W, q, dip, nu) - \
           U2 / (2 * np.pi) * chinnery(uz_ds, x, p, L, W, q, dip, nu) + \
           U3 / (2 * np.pi) * chinnery(uz_tf, x, p, L, W, q, dip, nu)
    ue = np.sin(strike) * ux - np.cos(strike) * uy
    un = np.cos(strike) * ux + np.sin(strike) * uy

    return ue,un,uz

'''
% Notes for I... and K... subfunctions:
%
%	1. original formulas use Lame's parameters as mu/(mu+lambda) which
%	   depends only on the Poisson's ratio = 1 - 2*nu
%	2. tests for cos(dip) == 0 are made with "cos(dip) > eps"
%	   because cos(90*np.pi/180) is not zero but = 6.1232e-17 (!)
%	   NOTE: don't use cosd and sind because of incompatibility
%	   with Matlab v6 and earlier...
'''

def chinnery(f, x, p, L, W, q, dip, nu):
    ''' % Chinnery's notation [equation (24) p. 1143]'''
    u = ( f(x, p, q, dip, nu) -
          f(x, p - W, q, dip, nu) -
          f(x - L, p, q, dip, nu) +
          f(x - L, p - W, q, dip, nu) )
    return u

'''
% Displacement subfunctions

% strike-slip displacement subfunctions [equation (25) p. 1144]
'''

def ux_ss(xi, eta, q, dip, nu):

    R = np.sqrt(xi ** 2 + eta ** 2 + q ** 2)
    u = xi * q / (R * (R + eta)) + \
        I1(xi, eta, q, dip, nu, R) * np.sin(dip)
    k = (q != 0)
    #u[k] = u[k] + np.arctan2( xi[k] * (eta[k]) , (q[k] * (R[k])))
    u[k] = u[k] + np.arctan( (xi[k] * eta[k]) / (q[k] * R[k]) )
    return u


def uy_ss(xi, eta, q, dip, nu):
    R = np.sqrt(xi ** 2 + eta ** 2 + q ** 2)
    u = (eta * np.cos(dip) + q * np.sin(dip)) * q / (R * (R + eta)) + \
        q * np.cos(dip) / (R + eta) + \
        I2(eta, q, dip, nu, R) * np.sin(dip)
    return u


def uz_ss(xi, eta, q, dip, nu):
    R = np.sqrt(xi ** 2 + eta ** 2 + q ** 2)
    db = eta * np.sin(dip) - q * np.cos(dip)
    u = (eta * np.sin(dip) - q * np.cos(dip)) * q / (R * (R + eta)) + \
        q * np.sin(dip) / (R + eta) + \
        I4(db, eta, q, dip, nu, R) * np.sin(dip)
    return u


def ux_ds(xi, eta, q, dip, nu):
    R = np.sqrt(xi ** 2 + eta ** 2 + q ** 2)
    u = q / R - \
        I3(eta, q, dip, nu, R) * np.sin(dip) * np.cos(dip)
    return u


def uy_ds(xi, eta, q, dip, nu):
    R = np.sqrt(xi ** 2 + eta ** 2 + q ** 2)
    u = ( (eta * np.cos(dip) + q * np.sin(dip)) * q / (R * (R + xi)) -
           I1(xi, eta, q, dip, nu, R) * np.sin(dip) * np.cos(dip) )
    k = (q != 0)
    u[k] = u[k] + np.cos(dip) * np.arctan( (xi[k] * eta[k]) / (q[k] * R[k]))
    return u


def uz_ds(xi, eta, q, dip, nu):
    R = np.sqrt(xi ** 2 + eta ** 2 + q ** 2)
    db = eta * np.sin(dip) - q * np.cos(dip)
    u = ( db * q / (R * (R + xi)) -
          I5(xi, eta, q, dip, nu, R, db) * np.sin(dip) * np.cos(dip) )
    k = (q != 0)
    #u[k] = u[k] + np.sin(dip) * np.arctan2(xi[k] * eta[k] , q[k] * R[k])
    u[k] = u[k] + np.sin(dip) * np.arctan( (xi[k] * eta[k]) / (q[k] * R[k]))
    return u


def ux_tf(xi, eta, q, dip, nu):
    R = np.sqrt(xi ** 2 + eta ** 2 + q ** 2)
    u = q ** 2 / (R * (R + eta)) - \
        I3(eta, q, dip, nu, R) * (np.sin(dip) ** 2)
    return u


def uy_tf(xi, eta, q, dip, nu):
    R = np.sqrt(xi ** 2 + eta ** 2 + q ** 2)
    u = - (eta * np.sin(dip) - q * np.cos(dip)) * q / (R * (R + xi)) - \
        np.sin(dip) * xi * q / (R * (R + eta)) - \
        I1(xi, eta, q, dip, nu, R) * (np.sin(dip) ** 2)
    k = (q != 0)
    #u[k] = u[k] + np.sin(dip) * np.arctan2(xi[k] * eta[k] , q[k] * R[k])
    u[k] = u[k] + np.sin(dip) * np.arctan( (xi[k] * eta[k]) , (q[k] * R[k]) )
    return u


def uz_tf(xi, eta, q, dip, nu):
    R = np.sqrt(xi**2 + eta**2 + q**2)
    db = eta * np.sin(dip) - q * np.cos(dip)
    u = (eta * np.cos(dip) + q * np.sin(dip)) * q / (R * (R + xi)) + \
         np.cos(dip) * xi * q / (R * (R + eta)) - \
         I5(xi, eta, q, dip, nu, R, db) * np.sin(dip)**2
    k = (q != 0) #not at depth=0?
    u[k] = u[k] - np.cos(dip) * np.arctan( (xi[k] * eta[k]) / (q[k] * R[k]) )
    return u


def I1(xi, eta, q, dip, nu, R):
    db = eta * np.sin(dip) - q * np.cos(dip)
    if np.cos(dip) > eps:
        I = (1 - 2 * nu) * (- xi / (np.cos(dip) * (R + db))) - \
            np.sin(dip) / np.cos(dip) * \
            I5(xi, eta, q, dip, nu, R, db)
    else:
        I = -(1 - 2 * nu) / 2 * xi * q / (R + db) ** 2
    return I


def I2(eta, q, dip, nu, R):
    I = (1 - 2 * nu) * (-np.log(R + eta)) - \
        I3(eta, q, dip, nu, R)
    return I


def I3(eta, q, dip, nu, R):
    yb = eta * np.cos(dip) + q * np.sin(dip)
    db = eta * np.sin(dip) - q * np.cos(dip)
    if np.cos(dip) > eps:
        I = (1 - 2 * nu) * (yb / (np.cos(dip) * (R + db)) - np.log(R + eta)) + \
            np.sin(dip) / np.cos(dip) * \
            I4(db, eta, q, dip, nu, R)
    else:
        I = (1 - 2 * nu) / 2 * (eta / (R + db) + yb * q / (R + db) ** 2 - np.log(R + eta))
    return I


def I4(db, eta, q, dip, nu, R):
    if np.cos(dip) > eps:
        I = (1 - 2 * nu) * 1.0 / np.cos(dip) * \
            (np.log(R + db) - np.sin(dip) * np.log(R + eta))
    else:
        I = - (1 - 2 * nu) * q / (R + db)
    return I


def I5(xi, eta, q, dip, nu, R, db):
    X = np.sqrt(xi**2 + q**2)
    if np.cos(dip) > eps:
        I = (1 - 2 * nu) * 2 / np.cos(dip) * \
             np.arctan( (eta * (X + q*np.cos(dip)) + X*(R + X) * np.sin(dip)) /
                        (xi*(R + X) * np.cos(dip)) ) 
        I[xi == 0] = 0
    else:
        I = -(1 - 2 * nu) * xi * np.sin(dip) / (R + db)
    return I

    # Strike-Slip Example
    '''
    print('Strike-slip fault benchmark')
    xcen = 0
    ycen = 0
    U = 1.0  # [m] U is slip
    # x,y are the observation points
    d = 1e-3  # [m] # d is depth (positive down)
    nu = 0.27  # nu is Poisson ratio
    # [degrees] delta is dip angle, 90.0 exactly might cause numerical issues?
    delta = 89.99
    strike = 90.0  # [degrees] counter clockwise from north
    length = 70e3  # [m] # len,W are the fault length and width, resp.
    width = 15e3  # [m]
    fault_type = 1  # fault_type is 1 2 3 for strike, dip, and opening
    tp = np.zeros_like(x)  # tp is the optional topo vector (size(x))
    params = dict(xcen=xcen, ycen=ycen, d=d, length=length, width=width, 
                  U=U, delta=delta, strike=strike, 
                  inc=inc, ald=ald, wavelength=wavelength, nu=nu)
    '''


def benchmark(inc=23.0, ald=-77.0, wavelength=5.66):
    '''
    Make sure python output matches matlab output (from Yuri Fialko's SIC)
    TODO: compare solutions to Okada 1985 Table 2
    '''
        # Make grid NOTE: odd number so that center is symmetrical
    n = 201
    xvec = np.linspace(-25e3,25e3,n)
    yvec = np.linspace(-25e3,25e3,n)
    x,y = np.meshgrid(xvec,yvec)

    # Run the model
    params = dict(x=x, y=y, xoff=0, yoff=0,
            depth=5e3, length=1e3, width=1e3, 
            slip=0.0, opening=0.0, 
            strike=0.0, dip=0.0, rake=0.0,
            nu=0.25)
    ux,uy,uz = forward(**params)

    data = np.dstack([ux, uy, uz])
    cart2los = get_cart2los(inc, ald, x)  # NOTE: not sure why 'x' being passed...
    los = np.sum(data * cart2los, axis=2)

    # Plots - NOTE: not working... need to fix!
    # Quick Fix: Change some variable names for the plots
    params['xcen'] = params['xoff']
    params['ycen'] = params['yoff']
    params['delta'] = params['dip']
    params['U'] = params['opening']
    params['inc'] = inc
    params['ald'] = ald
    params['wavelength'] = wavelength
    plot_components(x, y, ux, uy, uz, los, params)
    
    plot_los(x, y, ux, uy, uz, los, params)

    ind = np.nonzero(x == 0)
    plot_profile(ind, ux, uy, uz, los)




def get_cart2los(inc, ald, x):
    '''
    NOTE: possible sign convention issues with this function
    '''
    # x is data array
    # converted to LOS
    # los = data.dot(cart2los) * 1e2 # maybe use numpy.tensordot? not sure...
    # For now fake it:
    look = np.deg2rad(inc) * np.ones_like(x)  # incidence
    # heading (degreees clockwise from north)
    head = np.deg2rad(ald) * np.ones_like(x)
    # NOTE: matlab code default is -167 'clockwise from north' (same as hannsen text fig 5.1)
    # This is for descending envisat beam 2, asizmuth look direction (ALD) is
    # perpendicular to heading (-77)

    # however, make_los.pl generates unw file with [Incidence, ALD], ALD for ascending data is 77
    # make_los.pl defines "(alpha) azimuth pointing of s/c"
    EW2los = np.sin(head) * np.sin(look)
    NS2los = np.cos(head) * np.sin(look)
    Z2los = -np.cos(look)
    # NOTE: negative here implies uplift=positive in LOS
    cart2los = -np.dstack([EW2los, NS2los, Z2los])

    return cart2los



def plot_fault(fig, strike=None, delta=None, length=None, width=None, xcen=None, ycen=None, **kwargs):
    ''' matlab way to project fault plane onto surface'''
    # XB = [] #lists for multiple faults in same domain
    # YB = []

    # Project fault coordinates onto surface
    sins = np.sin(np.deg2rad(strike))
    coss = np.cos(np.deg2rad(strike))
    Lx = 0.5 * length * sins
    Ly = 0.5 * length * coss
    W = width * np.cos(np.deg2rad(delta))

    # Concatenate coordinates
    xb = np.array([-Lx + W * coss, -Lx, Lx, Lx + W * coss, -Lx + W * coss]) + xcen
    yb = np.array([-Ly - W * sins, -Ly, Ly, Ly - W * sins, -Ly - W * sins]) + ycen
    # XB.append(xb)
    # YB.append(yb)

    # scale for plotting
    xb = xb * 1e-3
    yb = yb * 1e-3

    # put it on the plots!
    for ax in fig.get_axes():
        ax.plot(xb, yb, 'w-', lw=2)


def plot_los_indicator(ax, ald):
    ''' Add LOS arrow indicator in axes coordinates
    Inputs:
        ax     axes to add to
        ald    azimuth look direction (second array in geo_incidence
    '''
    L = 0.1
    x0, y0 = (0.8, 0.8)
    dx = L * np.cos(np.pi / 2 - np.deg2rad(ald))
    dy = L * np.sin(np.pi / 2 - np.deg2rad(ald))
    ax.arrow(x0, y0, dx, dy, transform=ax.transAxes, color='k')  # add text too:
    ax.text(0.9, 0.9, 'LOS', ha='right', va='top',
            transform=ax.transAxes, fontweight='bold')
    # ax1.annotate('LOS', (x0,y0), xytext=(x0+dx,x0+dy), xycoords='axes fraction', textcoords='axes fraction',
    # arrowprops=dict(width=1,frac=0.3,headwidth=5,facecolor='black'),
    # fontweight='bold') # NOTE: imshow origin has effect on this


def plot_components(x, y, ux, uy, uz, los, params, profile=False):
    '''
    show components of deformation, along with projection into LOS
    NOTE: also would be cool to plot 3D surface!
    # just pass all parameters
    '''
    cmap = 'bwr'
    # Convert to km and cm for ploting
    x, y = np.array([x, y]) * 1e-3
    ux, uy, uz, los = np.array([ux, uy, uz, los]) * 1e2

    # step size for quiver plot resampling
    nx = 20
    ny = 20

    fig, (ax, ax1, ax2) = plt.subplots(1, 3,
                                subplot_kw=dict(aspect=1.0, adjustable='box-forced'),
                                sharex=True, sharey=True, figsize=(17, 6))  # fig_kw

    extent = [x.min(), x.max(), y.min(), y.max()]
    # plt.locator_params(tight=True, nbins=4) #control number of easting/northing ticks
    # sc = ax.scatter(x_km,y_km,c=data,cmap=plt.cm.bwr) #colormap not centered on zero
    # norm = MidpointNormalize(midpoint=0)
    # sc = ax.scatter(x_km,y_km,c=data,cmap=plt.cm.bwr,norm=norm)
    # im = ax.imshow(uz)
    # im = ax.pcolor(x,y,uz)
    im = ax.imshow(uz, extent=extent, cmap=cmap)
    # ax.quiver(x[::nx,::ny], y[::nx,::ny], ux[::nx,::ny], uy[::nx,::ny])
    # #vector sum - show in second figure
    ax.set_title('Vertical Displacement, Uz')
    ax.set_xlabel('EW Distance [km]')
    ax.set_ylabel('NS Distance [km]')
    # , pad=0.1) #ticks=MaxNLocator(nbins=5) #5 ticks only)
    cb = plt.colorbar(im, ax=ax, orientation='horizontal')
    cb.set_label('cm')

    # NOTE: look into code to see how error and wgt are determined..
    # sc1 = ax1.scatter(x_km,y_km,c=err,cmap=plt.cm.Reds)
    # im1 = ax1.imshow(ux)
    # im1 = ax1.pcolor(x,y,ux)
    im1 = ax1.imshow(ux, extent=extent, cmap=cmap)
    ax1.quiver(x[::nx, ::ny], y[::nx, ::ny], ux[::nx, ::ny], np.zeros_like(uy)[::nx, ::ny])
    ax1.set_title('EW Displacement, Ux')
    cb1 = plt.colorbar(im1, ax=ax1, orientation='horizontal')  # , pad=0.1)
    cb1.set_label('cm')

    # sc2 = ax2.scatter(x_km,y_km,c=wgt,cmap=plt.cm.Blues, norm=LogNorm())
    # cb2 = plt.colorbar(sc2, ax=ax2, orientation='horizontal', pad=0.1)
    # sc2 = ax2.scatter(x_km,y_km,c=wgt,cmap=plt.cm.Blues)
    # im2 = ax2.imshow(uy)
    # im2 = ax2.pcolor(x,y,uy)
    im2 = ax2.imshow(uy, extent=extent, cmap=cmap)
    ax2.quiver(x[::nx, ::ny], y[::nx, ::ny],
               np.zeros_like(ux)[::nx, ::ny], uy[::nx, ::ny])
    cb2 = plt.colorbar(im2, ax=ax2, orientation='horizontal')  # , pad=0.1)
    ax2.set_title('NS Displacement, Uy')
    cb2.set_label('cm')

    # Add crosshair grid:
    for a in (ax, ax1, ax2):
        a.axhline(linestyle=':', color='w')
        a.axvline(linestyle=':', color='w')

    plot_fault(fig, **params)

    plt.suptitle('Components of Deformation', fontsize=16, fontweight='bold')


def plot_los(x, y, ux, uy, uz, los, params, profile=False):
    ''' Separate figure showing displacement and Wrapped Phase in Radar     '''
    # Convert to km and cm for ploting
    cmap='bwr'
    x,y = np.array([x,y]) * 1e-3
    ux,uy,uz,los = np.array([ux,uy,uz,los]) * 1e2

    # extract a few varialbes from params dictionary
    inc = params['inc']
    ald = params['ald']
    wavelength = params['wavelength']

    # Set view
    nx=20
    ny=20
    extent = [x.min(), x.max(), y.min(), y.max()]

    # --------------
    fig, (ax,ax1,ax2) = plt.subplots(1,3,subplot_kw=dict(aspect=1.0, adjustable='box-forced'),sharex=True, sharey=True, figsize=(17,6))
    # vertical displacement w/ horizontal vectors # NOTE: add quiver scale arrow!
    im = ax.imshow(uz, extent=extent, cmap=cmap)
    ax.quiver(x[::nx,::ny], y[::nx,::ny], ux[::nx,::ny], uy[::nx,::ny])
    ax.set_title('Model Displacement Field')
    ax.set_xlabel('EW Distance [km]')
    ax.set_ylabel('NS Distance [km]')
    cb = plt.colorbar(im, ax=ax, orientation='horizontal', pad=0.1) #ticks=MaxNLocator(nbins=5) #5 ticks only)
    cb.set_label('cm')

    im = ax1.imshow(los, extent=extent, cmap=cmap)
    # ax1.quiver(x[::nx,::ny], y[::nx,::ny], ux[::nx,::ny], uy[::nx,::ny])
    plot_los_indicator(ax1,ald)
    ax1.set_title('LOS (inc,ald)=(%s,%s)' % (inc,ald) )
    cb = plt.colorbar(im, ax=ax1, orientation='horizontal', pad=0.1) #ticks=MaxNLocator(nbins=5) #5 ticks only)
    cb.set_label('cm')

    # wrapped LOS - think about why this works...
    los_wrapped = np.remainder(los - los.min(), wavelength/2.0) / (wavelength/2.0)
    im = ax2.imshow(los_wrapped, extent=extent, cmap='viridis', vmin=0, vmax=1)
    plot_los_indicator(ax2,ald)
    ax2.set_title('LOS Wrapped')
    cb = plt.colorbar(im, ax=ax2, orientation='horizontal', ticks=[], pad=0.1) #ticks=MaxNLocator(nbins=5) #5 ticks only)
    cb.set_label('{0} cm'.format(wavelength/2)) #1 color cycle = lambda/2

    plot_fault(fig,**params)

    # Add crosshair grid:
    for a in (ax,ax1,ax2):
        a.axhline(linestyle=':', color='w')
        a.axvline(linestyle=':', color='w')

    plt.suptitle('Model in Radar Line of Sight', fontsize=16, fontweight='bold')


def plot_profile(ind,ux,uy,uz,los,axis=0):
    ''' straight line profile through specified axis of ux,uy,uz,los'''
    # Show profile line in separate LOS plot
    plt.figure()
    plt.imshow(los, cmap='bwr')
    if axis == 0:
        plt.axhline(ind,color='k', lw=2)
        # plt.annotate('A',(ind,0))
    else:
        plt.vline(ind,color='k', lw=2)
    plt.title('Profile line')


    # Convert to km and cm for ploting
    # x,y = np.array([x,y]) * 1e-3
    ux,uy,uz,los = np.array([ux,uy,uz,los]) * 1e2

    if axis==1:
        ux,uy,uz,los = [x.T for x in [ux,uy,uz,los]]

    # extract profiles
    ux_p = ux[ind]
    uy_p = uy[ind]
    uz_p = uz[ind]
    los_p = los[ind]

    fig, (ax,ax1,ax2,ax3) = plt.subplots(1,4,sharex=True, sharey=True, figsize=(17,6))
    ax.plot(ux_p,'k.-',lw=2)
    ax.set_title('Ux')
    ax.set_ylabel('Displacement [cm]')
    ax.set_xlabel('Distance [km]')
    ax.text(0,0.9,'A',fontweight='bold',ma='center',transform=ax.transAxes)
    ax.text(0.9,0.9,'B',fontweight='bold',ma='center',transform=ax.transAxes)

    ax1.plot(uy_p,'k.-',lw=2)
    ax1.set_title('Uy')

    ax2.plot(uz_p,'k.-',lw=2)
    ax2.set_title('Uz')

    ax3.plot(los_p,'k.-',lw=2)
    ax3.set_title('LOS')

    for a in (ax,ax1,ax2,ax3):
        a.axhline(0,color='gray',linestyle='--')
        a.axvline(ind,color='gray',linestyle='--')
        a.grid(True)

    # ratio of uz to ur
    # NOTE: just print max ratio
    print('Ur/Uz = ', ux_p.max() / uz_p.max())
    '''
    plt.figure()
    plt.plot(uz_p/ux_p,'k.-',lw=2)
    plt.xlabel('Distance [km]')
    plt.ylabel('Uz/Ur Ratio')
    plt.title('Vertical vs. Horizontal Displacements')
    plt.show()
    '''

if __name__ == '__main__':
    # Benchmark matching matlab demo.m
    print('Functions intended for use within roipy. Here is a benchmark')
    benchmark()
